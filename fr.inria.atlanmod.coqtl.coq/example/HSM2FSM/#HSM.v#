
(********************************************************************
	@name Coq declarations for metamodel: <HSM>
	@date 2018/07/10 17:38:28
	@description Automatically generated by Ecore2Coq transformation.
 ********************************************************************)

(* Coq libraries *)
Require Import Bool.
Require Import String.
Require Import List.
Require Import Multiset.
Require Import ListSet.
Require Import Omega.
Require Import Coq.Logic.Eqdep_dec.

(* CoqTL libraries *)
Require Import core.utils.tTop.
Require Import core.Metamodel.
Require Import core.Model.

(* Base types *)
Inductive StateMachine : Set :=
  BuildStateMachine :
  (* name *) string ->
  StateMachine.
  
Inductive Transition : Set :=
  BuildTransition :
  (* label *) string ->
  Transition.
  
Inductive AbstractState : Set :=
  BuildAbstractState :
  (* name *) string ->
  AbstractState.
  
Inductive InitialState : Set :=
  BuildInitialState :
  (* name *) string ->
  InitialState.
  
Inductive RegularState : Set :=
  BuildRegularState :
  (* name *) string ->
  RegularState.
  
Inductive CompositeState : Set :=
  BuildCompositeState :
  (* name *) string ->
  CompositeState.
  

Inductive StateMachineTransitions : Set :=
   BuildStateMachineTransitions :
   StateMachine ->
   list Transition ->
   StateMachineTransitions.
Inductive StateMachineStates : Set :=
   BuildStateMachineStates :
   StateMachine ->
   list AbstractState ->
   StateMachineStates.

Inductive TransitionStateMachine : Set :=
   BuildTransitionStateMachine :
   Transition ->
   StateMachine ->
   TransitionStateMachine.
Inductive TransitionSource : Set :=
   BuildTransitionSource :
   Transition ->
   AbstractState ->
   TransitionSource.
Inductive TransitionTarget : Set :=
   BuildTransitionTarget :
   Transition ->
   AbstractState ->
   TransitionTarget.

Inductive AbstractStateStateMachine : Set :=
   BuildAbstractStateStateMachine :
   AbstractState ->
   StateMachine ->
   AbstractStateStateMachine.
Inductive AbstractStateCompositeState : Set :=
   BuildAbstractStateCompositeState :
   AbstractState ->
   CompositeState ->
   AbstractStateCompositeState.

Inductive InitialStateStateMachine : Set :=
   BuildInitialStateStateMachine :
   InitialState ->
   StateMachine ->
   InitialStateStateMachine.
Inductive InitialStateCompositeState : Set :=
   BuildInitialStateCompositeState :
   InitialState ->
   CompositeState ->
   InitialStateCompositeState.

Inductive RegularStateStateMachine : Set :=
   BuildRegularStateStateMachine :
   RegularState ->
   StateMachine ->
   RegularStateStateMachine.
Inductive RegularStateCompositeState : Set :=
   BuildRegularStateCompositeState :
   RegularState ->
   CompositeState ->
   RegularStateCompositeState.

Inductive CompositeStateStateMachine : Set :=
   BuildCompositeStateStateMachine :
   CompositeState ->
   StateMachine ->
   CompositeStateStateMachine.
Inductive CompositeStateCompositeState : Set :=
   BuildCompositeStateCompositeState :
   CompositeState ->
   CompositeState ->
   CompositeStateCompositeState.
Inductive CompositeStateStates : Set :=
   BuildCompositeStateStates :
   CompositeState ->
   list AbstractState ->
   CompositeStateStates.


(* Accessors *)
Definition getStateMachineName (s : StateMachine) : string :=
  match s with BuildStateMachine name  => name end.



Definition getTransitionLabel (t : Transition) : string :=
  match t with BuildTransition label  => label end.



Definition getAbstractStateName (a : AbstractState) : string :=
  match a with BuildAbstractState name  => name end.



Definition getInitialStateName (i : InitialState) : string :=
  match i with BuildInitialState name  => name end.



Definition getRegularStateName (r : RegularState) : string :=
  match r with BuildRegularState name  => name end.



Definition getCompositeStateName (c : CompositeState) : string :=
  match c with BuildCompositeState name  => name end.




(* Equality for Types *)
(**? We define eq for Eclass on their fist attribute **)
Definition beq_StateMachine (st_arg1 : StateMachine) (st_arg2 : StateMachine) : bool :=
  beq_string (getStateMachineName st_arg1) (getStateMachineName st_arg2).

Definition beq_Transition (tr_arg1 : Transition) (tr_arg2 : Transition) : bool :=
  beq_string (getTransitionLabel tr_arg1) (getTransitionLabel tr_arg2).

Definition beq_AbstractState (ab_arg1 : AbstractState) (ab_arg2 : AbstractState) : bool :=
  beq_string (getAbstractStateName ab_arg1) (getAbstractStateName ab_arg2).

Definition beq_InitialState (in_arg1 : InitialState) (in_arg2 : InitialState) : bool :=
  beq_string (getInitialStateName in_arg1) (getInitialStateName in_arg2).

Definition beq_RegularState (re_arg1 : RegularState) (re_arg2 : RegularState) : bool :=
  beq_string (getRegularStateName re_arg1) (getRegularStateName re_arg2).

Definition beq_CompositeState (co_arg1 : CompositeState) (co_arg2 : CompositeState) : bool :=
  beq_string (getCompositeStateName co_arg1) (getCompositeStateName co_arg2).


(* Meta-types *)
Inductive HSMMetamodel_EClass : Set :=
  | StateMachineEClass
  | TransitionEClass
  | AbstractStateEClass
  | InitialStateEClass
  | RegularStateEClass
  | CompositeStateEClass
.

Definition HSMMetamodel_getTypeByEClass (hsec_arg : HSMMetamodel_EClass) : Set :=
  match hsec_arg with
    | StateMachineEClass => StateMachine
    | TransitionEClass => Transition
    | AbstractStateEClass => AbstractState
    | InitialStateEClass => InitialState
    | RegularStateEClass => RegularState
    | CompositeStateEClass => CompositeState
  end.

(**? confusing name convention **)
Definition HSMMetamodel_getEAttributeTypesByEClass (hsec_arg : HSMMetamodel_EClass) : Set :=
  match hsec_arg with
    | StateMachineEClass => (string)
    | TransitionEClass => (string)
    | AbstractStateEClass => (string)
    | InitialStateEClass => (string)
    | RegularStateEClass => (string)
    | CompositeStateEClass => (string)
  end.

Inductive HSMMetamodel_EReference : Set :=
| StateMachineTransitionsEReference
| StateMachineStatesEReference
| TransitionStateMachineEReference
| TransitionSourceEReference
| TransitionTargetEReference
| AbstractStateStateMachineEReference
| AbstractStateCompositeStateEReference
| InitialStateStateMachineEReference
| InitialStateCompositeStateEReference
| RegularStateStateMachineEReference
| RegularStateCompositeStateEReference
| CompositeStateStateMachineEReference
| CompositeStateCompositeStateEReference
| CompositeStateStatesEReference
.

Definition HSMMetamodel_getTypeByEReference (hser_arg : HSMMetamodel_EReference) : Set :=
  match hser_arg with
| StateMachineTransitionsEReference => StateMachineTransitions
| StateMachineStatesEReference => StateMachineStates
| TransitionStateMachineEReference => TransitionStateMachine
| TransitionSourceEReference => TransitionSource
| TransitionTargetEReference => TransitionTarget
| AbstractStateStateMachineEReference => AbstractStateStateMachine
| AbstractStateCompositeStateEReference => AbstractStateCompositeState
| InitialStateStateMachineEReference => InitialStateStateMachine
| InitialStateCompositeStateEReference => InitialStateCompositeState
| RegularStateStateMachineEReference => RegularStateStateMachine
| RegularStateCompositeStateEReference => RegularStateCompositeState
| CompositeStateStateMachineEReference => CompositeStateStateMachine
| CompositeStateCompositeStateEReference => CompositeStateCompositeState
| CompositeStateStatesEReference => CompositeStateStates
  end.

(**? confusing name convention **)
Definition HSMMetamodel_getERoleTypesByEReference (hser_arg : HSMMetamodel_EReference) : Set :=
  match hser_arg with
| StateMachineTransitionsEReference => (StateMachine * list Transition)
| StateMachineStatesEReference => (StateMachine * list AbstractState)
| TransitionStateMachineEReference => (Transition * StateMachine)
| TransitionSourceEReference => (Transition * AbstractState)
| TransitionTargetEReference => (Transition * AbstractState)
| AbstractStateStateMachineEReference => (AbstractState * StateMachine)
| AbstractStateCompositeStateEReference => (AbstractState * CompositeState)
| InitialStateStateMachineEReference => (InitialState * StateMachine)
| InitialStateCompositeStateEReference => (InitialState * CompositeState)
| RegularStateStateMachineEReference => (RegularState * StateMachine)
| RegularStateCompositeStateEReference => (RegularState * CompositeState)
| CompositeStateStateMachineEReference => (CompositeState * StateMachine)
| CompositeStateCompositeStateEReference => (CompositeState * CompositeState)
| CompositeStateStatesEReference => (CompositeState * list AbstractState)
  end.

(* Generic types *)





(**? Changed Ctr name **)
Inductive HSMMetamodel_EObject : Set :=
 | Build_HSMMetamodel_EObject : 
    forall (hsec_arg: HSMMetamodel_EClass), (HSMMetamodel_getTypeByEClass hsec_arg) -> HSMMetamodel_EObject.

Inductive HSMMetamodel_ELink : Set :=
 | Build_HSMMetamodel_ELink : 
    forall (hser_arg:HSMMetamodel_EReference), (HSMMetamodel_getTypeByEReference hser_arg) -> HSMMetamodel_ELink.

(* Reflective functions *)

Lemma HSMMetamodel_eqEClass_dec : 
 forall (hsec_arg1:HSMMetamodel_EClass) (hsec_arg2:HSMMetamodel_EClass), { hsec_arg1 = hsec_arg2 } + { hsec_arg1 <> hsec_arg2 }.
Proof. repeat decide equality. Defined.

Lemma HSMMetamodel_eqEReference_dec : 
 forall (hser_arg1:HSMMetamodel_EReference) (hser_arg2:HSMMetamodel_EReference), { hser_arg1 = hser_arg2 } + { hser_arg1 <> hser_arg2 }.
Proof. repeat decide equality. Defined.

Definition HSMMetamodel_getEClass (hseo_arg : HSMMetamodel_EObject) : HSMMetamodel_EClass :=
   match hseo_arg with
  | (Build_HSMMetamodel_EObject hseo_arg _) => hseo_arg
   end.

Definition HSMMetamodel_getEReference (hsel_arg : HSMMetamodel_ELink) : HSMMetamodel_EReference :=
   match hsel_arg with
  | (Build_HSMMetamodel_ELink hsel_arg _) => hsel_arg
   end.

Definition HSMMetamodel_instanceOfEClass (hsec_arg: HSMMetamodel_EClass) (hseo_arg : HSMMetamodel_EObject): bool :=
  if HSMMetamodel_eqEClass_dec (HSMMetamodel_getEClass hseo_arg) hsec_arg then true else false.

Definition HSMMetamodel_instanceOfEReference (hser_arg: HSMMetamodel_EReference) (hsel_arg : HSMMetamodel_ELink): bool :=
  if HSMMetamodel_eqEReference_dec (HSMMetamodel_getEReference hsel_arg) hser_arg then true else false.

(**? confusing name convention **)

Definition HSMMetamodel_getEObjectFromEAttributeValues (hsec_arg : HSMMetamodel_EClass) : (HSMMetamodel_getEAttributeTypesByEClass hsec_arg) -> HSMMetamodel_EObject :=
  match hsec_arg with
    | StateMachineEClass => (fun (p: (string)) => (Build_HSMMetamodel_EObject StateMachineEClass (BuildStateMachine p)))
    | TransitionEClass => (fun (p: (string)) => (Build_HSMMetamodel_EObject TransitionEClass (BuildTransition p)))
    | AbstractStateEClass => (fun (p: (string)) => (Build_HSMMetamodel_EObject AbstractStateEClass (BuildAbstractState p)))
    | InitialStateEClass => (fun (p: (string)) => (Build_HSMMetamodel_EObject InitialStateEClass (BuildInitialState p)))
    | RegularStateEClass => (fun (p: (string)) => (Build_HSMMetamodel_EObject RegularStateEClass (BuildRegularState p)))
    | CompositeStateEClass => (fun (p: (string)) => (Build_HSMMetamodel_EObject CompositeStateEClass (BuildCompositeState p)))
  end.

(**? confusing name convention **)
Definition HSMMetamodel_getELinkFromERoleValues (hser_arg : HSMMetamodel_EReference) : (HSMMetamodel_getERoleTypesByEReference hser_arg) -> HSMMetamodel_ELink :=
  match hser_arg with
| StateMachineTransitionsEReference => (fun (p: (StateMachine * list Transition)) => (Build_HSMMetamodel_ELink StateMachineTransitionsEReference (BuildStateMachineTransitions (fst p) (snd p))))
| StateMachineStatesEReference => (fun (p: (StateMachine * list AbstractState)) => (Build_HSMMetamodel_ELink StateMachineStatesEReference (BuildStateMachineStates (fst p) (snd p))))
| TransitionStateMachineEReference => (fun (p: (Transition * StateMachine)) => (Build_HSMMetamodel_ELink TransitionStateMachineEReference (BuildTransitionStateMachine (fst p) (snd p))))
| TransitionSourceEReference => (fun (p: (Transition * AbstractState)) => (Build_HSMMetamodel_ELink TransitionSourceEReference (BuildTransitionSource (fst p) (snd p))))
| TransitionTargetEReference => (fun (p: (Transition * AbstractState)) => (Build_HSMMetamodel_ELink TransitionTargetEReference (BuildTransitionTarget (fst p) (snd p))))
| AbstractStateStateMachineEReference => (fun (p: (AbstractState * StateMachine)) => (Build_HSMMetamodel_ELink AbstractStateStateMachineEReference (BuildAbstractStateStateMachine (fst p) (snd p))))
| AbstractStateCompositeStateEReference => (fun (p: (AbstractState * CompositeState)) => (Build_HSMMetamodel_ELink AbstractStateCompositeStateEReference (BuildAbstractStateCompositeState (fst p) (snd p))))
| InitialStateStateMachineEReference => (fun (p: (InitialState * StateMachine)) => (Build_HSMMetamodel_ELink InitialStateStateMachineEReference (BuildInitialStateStateMachine (fst p) (snd p))))
| InitialStateCompositeStateEReference => (fun (p: (InitialState * CompositeState)) => (Build_HSMMetamodel_ELink InitialStateCompositeStateEReference (BuildInitialStateCompositeState (fst p) (snd p))))
| RegularStateStateMachineEReference => (fun (p: (RegularState * StateMachine)) => (Build_HSMMetamodel_ELink RegularStateStateMachineEReference (BuildRegularStateStateMachine (fst p) (snd p))))
| RegularStateCompositeStateEReference => (fun (p: (RegularState * CompositeState)) => (Build_HSMMetamodel_ELink RegularStateCompositeStateEReference (BuildRegularStateCompositeState (fst p) (snd p))))
| CompositeStateStateMachineEReference => (fun (p: (CompositeState * StateMachine)) => (Build_HSMMetamodel_ELink CompositeStateStateMachineEReference (BuildCompositeStateStateMachine (fst p) (snd p))))
| CompositeStateCompositeStateEReference => (fun (p: (CompositeState * CompositeState)) => (Build_HSMMetamodel_ELink CompositeStateCompositeStateEReference (BuildCompositeStateCompositeState (fst p) (snd p))))
| CompositeStateStatesEReference => (fun (p: (CompositeState * list AbstractState)) => (Build_HSMMetamodel_ELink CompositeStateStatesEReference (BuildCompositeStateStates (fst p) (snd p))))
  end.

Definition HSMMetamodel_toEClass (hsec_arg : HSMMetamodel_EClass) (hseo_arg : HSMMetamodel_EObject) : option (HSMMetamodel_getTypeByEClass hsec_arg).
Proof.
  destruct hseo_arg as [arg1 arg2].
  destruct (HSMMetamodel_eqEClass_dec arg1 hsec_arg) as [e|] eqn:dec_case.
  - rewrite e in arg2.
    exact (Some arg2).
  - exact None.
Defined.

Definition HSMMetamodel_toEReference (hser_arg : HSMMetamodel_EReference) (hsel_arg : HSMMetamodel_ELink) : option (HSMMetamodel_getTypeByEReference hser_arg).
Proof.
  destruct hsel_arg as [arg1 arg2].
  destruct (HSMMetamodel_eqEReference_dec arg1 hser_arg) as [e|] eqn:dec_case.
  - rewrite e in arg2.
  	exact (Some arg2).
  - exact None.
Defined.

(* Generic functions *)
Definition HSMMetamodel_toEObjectFromStateMachine (st_arg :StateMachine) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject StateMachineEClass st_arg).
Coercion HSMMetamodel_toEObjectFromStateMachine : StateMachine >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromTransition (tr_arg :Transition) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject TransitionEClass tr_arg).
Coercion HSMMetamodel_toEObjectFromTransition : Transition >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromAbstractState (ab_arg :AbstractState) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject AbstractStateEClass ab_arg).
Coercion HSMMetamodel_toEObjectFromAbstractState : AbstractState >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromInitialState (in_arg :InitialState) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject InitialStateEClass in_arg).
Coercion HSMMetamodel_toEObjectFromInitialState : InitialState >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromRegularState (re_arg :RegularState) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject RegularStateEClass re_arg).
Coercion HSMMetamodel_toEObjectFromRegularState : RegularState >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromCompositeState (co_arg :CompositeState) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject CompositeStateEClass co_arg).
Coercion HSMMetamodel_toEObjectFromCompositeState : CompositeState >-> HSMMetamodel_EObject.


(**? what are these for **)
Definition HSMMetamodel_toEObject (hseo_arg : HSMMetamodel_EObject) : HSMMetamodel_EObject := hseo_arg.
Definition HSMMetamodel_toELink (hsel_arg : HSMMetamodel_ELink) : HSMMetamodel_ELink := hsel_arg.
Definition HSMModel := Model HSMMetamodel_EObject HSMMetamodel_ELink.

Definition HSMMetamodel_toEObjectOfEClass (hsec_arg: HSMMetamodel_EClass) (t: HSMMetamodel_getTypeByEClass hsec_arg) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject hsec_arg t).


Fixpoint HSMMetamodel_getStateMachineTransitionsOnLinks (st_arg : StateMachine) (l : list HSMMetamodel_ELink) : option (list Transition) :=
match l with
| (Build_HSMMetamodel_ELink StateMachineTransitionsEReference (BuildStateMachineTransitions StateMachine_ctr transitions_ctr)) :: l' => 
	  if beq_StateMachine StateMachine_ctr st_arg then Some transitions_ctr else HSMMetamodel_getStateMachineTransitionsOnLinks st_arg l'
| _ :: l' => HSMMetamodel_getStateMachineTransitionsOnLinks st_arg l'
| nil => None
end.

Definition getStateMachineTransitionsOnLinks (st_arg : StateMachine) (m : HSMModel) : option (list Transition) :=
  HSMMetamodel_getStateMachineTransitionsOnLinks st_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getStateMachineStatesOnLinks (st_arg : StateMachine) (l : list HSMMetamodel_ELink) : option (list AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink StateMachineStatesEReference (BuildStateMachineStates StateMachine_ctr states_ctr)) :: l' => 
	  if beq_StateMachine StateMachine_ctr st_arg then Some states_ctr else HSMMetamodel_getStateMachineStatesOnLinks st_arg l'
| _ :: l' => HSMMetamodel_getStateMachineStatesOnLinks st_arg l'
| nil => None
end.

Definition getStateMachineStatesOnLinks (st_arg : StateMachine) (m : HSMModel) : option (list AbstractState) :=
  HSMMetamodel_getStateMachineStatesOnLinks st_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getTransitionStateMachineOnLinks (tr_arg : Transition) (l : list HSMMetamodel_ELink) : option (StateMachine) :=
match l with
| (Build_HSMMetamodel_ELink TransitionStateMachineEReference (BuildTransitionStateMachine Transition_ctr stateMachine_ctr)) :: l' => 
	  if beq_Transition Transition_ctr tr_arg then Some stateMachine_ctr else HSMMetamodel_getTransitionStateMachineOnLinks tr_arg l'
| _ :: l' => HSMMetamodel_getTransitionStateMachineOnLinks tr_arg l'
| nil => None
end.

Definition getTransitionStateMachineOnLinks (tr_arg : Transition) (m : HSMModel) : option (StateMachine) :=
  HSMMetamodel_getTransitionStateMachineOnLinks tr_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getTransitionSourceOnLinks (tr_arg : Transition) (l : list HSMMetamodel_ELink) : option (AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink TransitionSourceEReference (BuildTransitionSource Transition_ctr source_ctr)) :: l' => 
	  if beq_Transition Transition_ctr tr_arg then Some source_ctr else HSMMetamodel_getTransitionSourceOnLinks tr_arg l'
| _ :: l' => HSMMetamodel_getTransitionSourceOnLinks tr_arg l'
| nil => None
end.

Definition getTransitionSourceOnLinks (tr_arg : Transition) (m : HSMModel) : option (AbstractState) :=
  HSMMetamodel_getTransitionSourceOnLinks tr_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getTransitionTargetOnLinks (tr_arg : Transition) (l : list HSMMetamodel_ELink) : option (AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink TransitionTargetEReference (BuildTransitionTarget Transition_ctr target_ctr)) :: l' => 
	  if beq_Transition Transition_ctr tr_arg then Some target_ctr else HSMMetamodel_getTransitionTargetOnLinks tr_arg l'
| _ :: l' => HSMMetamodel_getTransitionTargetOnLinks tr_arg l'
| nil => None
end.

Definition getTransitionTargetOnLinks (tr_arg : Transition) (m : HSMModel) : option (AbstractState) :=
  HSMMetamodel_getTransitionTargetOnLinks tr_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getAbstractStateStateMachineOnLinks (ab_arg : AbstractState) (l : list HSMMetamodel_ELink) : option (StateMachine) :=
match l with
| (Build_HSMMetamodel_ELink AbstractStateStateMachineEReference (BuildAbstractStateStateMachine AbstractState_ctr stateMachine_ctr)) :: l' => 
	  if beq_AbstractState AbstractState_ctr ab_arg then Some stateMachine_ctr else HSMMetamodel_getAbstractStateStateMachineOnLinks ab_arg l'
| _ :: l' => HSMMetamodel_getAbstractStateStateMachineOnLinks ab_arg l'
| nil => None
end.

Definition getAbstractStateStateMachineOnLinks (ab_arg : AbstractState) (m : HSMModel) : option (StateMachine) :=
  HSMMetamodel_getAbstractStateStateMachineOnLinks ab_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getAbstractStateCompositeStateOnLinks (ab_arg : AbstractState) (l : list HSMMetamodel_ELink) : option (CompositeState) :=
match l with
| (Build_HSMMetamodel_ELink AbstractStateCompositeStateEReference (BuildAbstractStateCompositeState AbstractState_ctr compositeState_ctr)) :: l' => 
	  if beq_AbstractState AbstractState_ctr ab_arg then Some compositeState_ctr else HSMMetamodel_getAbstractStateCompositeStateOnLinks ab_arg l'
| _ :: l' => HSMMetamodel_getAbstractStateCompositeStateOnLinks ab_arg l'
| nil => None
end.

Definition getAbstractStateCompositeStateOnLinks (ab_arg : AbstractState) (m : HSMModel) : option (CompositeState) :=
  HSMMetamodel_getAbstractStateCompositeStateOnLinks ab_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getInitialStateStateMachineOnLinks (in_arg : InitialState) (l : list HSMMetamodel_ELink) : option (StateMachine) :=
match l with
| (Build_HSMMetamodel_ELink InitialStateStateMachineEReference (BuildInitialStateStateMachine InitialState_ctr stateMachine_ctr)) :: l' => 
	  if beq_InitialState InitialState_ctr in_arg then Some stateMachine_ctr else HSMMetamodel_getInitialStateStateMachineOnLinks in_arg l'
| _ :: l' => HSMMetamodel_getInitialStateStateMachineOnLinks in_arg l'
| nil => None
end.

Definition getInitialStateStateMachineOnLinks (in_arg : InitialState) (m : HSMModel) : option (StateMachine) :=
  HSMMetamodel_getInitialStateStateMachineOnLinks in_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getInitialStateCompositeStateOnLinks (in_arg : InitialState) (l : list HSMMetamodel_ELink) : option (CompositeState) :=
match l with
| (Build_HSMMetamodel_ELink InitialStateCompositeStateEReference (BuildInitialStateCompositeState InitialState_ctr compositeState_ctr)) :: l' => 
	  if beq_InitialState InitialState_ctr in_arg then Some compositeState_ctr else HSMMetamodel_getInitialStateCompositeStateOnLinks in_arg l'
| _ :: l' => HSMMetamodel_getInitialStateCompositeStateOnLinks in_arg l'
| nil => None
end.

Definition getInitialStateCompositeStateOnLinks (in_arg : InitialState) (m : HSMModel) : option (CompositeState) :=
  HSMMetamodel_getInitialStateCompositeStateOnLinks in_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getRegularStateStateMachineOnLinks (re_arg : RegularState) (l : list HSMMetamodel_ELink) : option (StateMachine) :=
match l with
| (Build_HSMMetamodel_ELink RegularStateStateMachineEReference (BuildRegularStateStateMachine RegularState_ctr stateMachine_ctr)) :: l' => 
	  if beq_RegularState RegularState_ctr re_arg then Some stateMachine_ctr else HSMMetamodel_getRegularStateStateMachineOnLinks re_arg l'
| _ :: l' => HSMMetamodel_getRegularStateStateMachineOnLinks re_arg l'
| nil => None
end.

Definition getRegularStateStateMachineOnLinks (re_arg : RegularState) (m : HSMModel) : option (StateMachine) :=
  HSMMetamodel_getRegularStateStateMachineOnLinks re_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getRegularStateCompositeStateOnLinks (re_arg : RegularState) (l : list HSMMetamodel_ELink) : option (CompositeState) :=
match l with
| (Build_HSMMetamodel_ELink RegularStateCompositeStateEReference (BuildRegularStateCompositeState RegularState_ctr compositeState_ctr)) :: l' => 
	  if beq_RegularState RegularState_ctr re_arg then Some compositeState_ctr else HSMMetamodel_getRegularStateCompositeStateOnLinks re_arg l'
| _ :: l' => HSMMetamodel_getRegularStateCompositeStateOnLinks re_arg l'
| nil => None
end.

Definition getRegularStateCompositeStateOnLinks (re_arg : RegularState) (m : HSMModel) : option (CompositeState) :=
  HSMMetamodel_getRegularStateCompositeStateOnLinks re_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getCompositeStateStateMachineOnLinks (co_arg : CompositeState) (l : list HSMMetamodel_ELink) : option (StateMachine) :=
match l with
| (Build_HSMMetamodel_ELink CompositeStateStateMachineEReference (BuildCompositeStateStateMachine CompositeState_ctr stateMachine_ctr)) :: l' => 
	  if beq_CompositeState CompositeState_ctr co_arg then Some stateMachine_ctr else HSMMetamodel_getCompositeStateStateMachineOnLinks co_arg l'
| _ :: l' => HSMMetamodel_getCompositeStateStateMachineOnLinks co_arg l'
| nil => None
end.

Definition getCompositeStateStateMachineOnLinks (co_arg : CompositeState) (m : HSMModel) : option (StateMachine) :=
  HSMMetamodel_getCompositeStateStateMachineOnLinks co_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getCompositeStateCompositeStateOnLinks (co_arg : CompositeState) (l : list HSMMetamodel_ELink) : option (CompositeState) :=
match l with
| (Build_HSMMetamodel_ELink CompositeStateCompositeStateEReference (BuildCompositeStateCompositeState CompositeState_ctr compositeState_ctr)) :: l' => 
	  if beq_CompositeState CompositeState_ctr co_arg then Some compositeState_ctr else HSMMetamodel_getCompositeStateCompositeStateOnLinks co_arg l'
| _ :: l' => HSMMetamodel_getCompositeStateCompositeStateOnLinks co_arg l'
| nil => None
end.

Definition getCompositeStateCompositeStateOnLinks (co_arg : CompositeState) (m : HSMModel) : option (CompositeState) :=
  HSMMetamodel_getCompositeStateCompositeStateOnLinks co_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getCompositeStateStatesOnLinks (co_arg : CompositeState) (l : list HSMMetamodel_ELink) : option (list AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink CompositeStateStatesEReference (BuildCompositeStateStates CompositeState_ctr states_ctr)) :: l' => 
	  if beq_CompositeState CompositeState_ctr co_arg then Some states_ctr else HSMMetamodel_getCompositeStateStatesOnLinks co_arg l'
| _ :: l' => HSMMetamodel_getCompositeStateStatesOnLinks co_arg l'
| nil => None
end.

Definition getCompositeStateStatesOnLinks (co_arg : CompositeState) (m : HSMModel) : option (list AbstractState) :=
  HSMMetamodel_getCompositeStateStatesOnLinks co_arg (@allModelLinks _ _ m).


Definition HSMMetamodel_defaultInstanceOfEClass (hsec_arg: HSMMetamodel_EClass) : (HSMMetamodel_getTypeByEClass hsec_arg) :=
  match hsec_arg with
  | StateMachineEClass => (BuildStateMachine "")
  | TransitionEClass => (BuildTransition "")
  | AbstractStateEClass => (BuildAbstractState "")
  | InitialStateEClass => (BuildInitialState "")
  | RegularStateEClass => (BuildRegularState "")
  | CompositeStateEClass => (BuildCompositeState "")
  end.

(* Typeclass Instance *)
Instance HSMMetamodel : Metamodel HSMMetamodel_EObject HSMMetamodel_ELink HSMMetamodel_EClass HSMMetamodel_EReference :=
  {
    denoteModelClass := HSMMetamodel_getTypeByEClass;
    denoteModelReference := HSMMetamodel_getTypeByEReference;
    toModelClass := HSMMetamodel_toEClass;
    toModelReference := HSMMetamodel_toEReference;
    toModelElement := HSMMetamodel_toEObjectOfEClass;
    toModelLink := HSMMetamodel_toELinkOfEReference;
    bottomModelClass := HSMMetamodel_defaultInstanceOfEClass;

    (* Theorems *)
    eqModelClass_dec := HSMMetamodel_eqEClass_dec;
    eqModelReference_dec := HSMMetamodel_eqEReference_dec;

    (* Constructors *)
    BuildModelElement := Build_HSMMetamodel_EObject;
    BuildModelLink := Build_HSMMetamodel_ELink;
  }.
  
(* Useful lemmas *)
Lemma HSM_invert : 
  forall (hsec_arg: HSMMetamodel_EClass) (t1 t2: HSMMetamodel_getTypeByEClass hsec_arg), Build_HSMMetamodel_EObject hsec_arg t1 = Build_HSMMetamodel_EObject hsec_arg t2 -> t1 = t2.
Proof.
  intros.
  inversion H.
  apply inj_pair2_eq_dec in H1.
  exact H1.
  apply HSMMetamodel_eqEClass_dec.
Qed.
