
(********************************************************************
	@name Coq declarations for metamodel: <HSM>
	@date 2018/08/14 16:12:50
	@description Automatically generated by Ecore2Coq transformation.
 ********************************************************************)

(* Coq libraries *)
Require Import Bool.
Require Import String.
Require Import List.
Require Import Multiset.
Require Import ListSet.
Require Import Omega.
Require Import Coq.Logic.Eqdep_dec.

(* CoqTL libraries *)
Require Import core.utils.tTop.
Require Import core.Metamodel.
Require Import core.Model.

	
(* Base types *)
Inductive StateMachine : Set :=
  BuildStateMachine :
  (* name *) string ->
  (* StateMachineID *) string ->
  StateMachine.
  
Inductive Transition : Set :=
  BuildTransition :
  (* label *) string ->
  (* TransitionID *) string ->
  Transition.
  
Inductive AbstractState : Set :=
  BuildAbstractState :
  (* name *) string ->
  (* AbstractStateID *) string ->
  AbstractState.
  
Inductive InitialState : Set :=
  BuildInitialState :
  (* Inheritence Attribute *) AbstractState -> 
  (* InitialStateID *) string ->
  InitialState.
  
Inductive RegularState : Set :=
  BuildRegularState :
  (* Inheritence Attribute *) AbstractState -> 
  (* RegularStateID *) string ->
  RegularState.
  
Inductive CompositeState : Set :=
  BuildCompositeState :
  (* Inheritence Attribute *) AbstractState -> 
  (* CompositeStateID *) string ->
  CompositeState.
  

Inductive StateMachineTransitions : Set :=
   BuildStateMachineTransitions :
   StateMachine ->
   list Transition ->
   StateMachineTransitions.
Inductive StateMachineStates : Set :=
   BuildStateMachineStates :
   StateMachine ->
   list AbstractState ->
   StateMachineStates.

Inductive TransitionStateMachine : Set :=
   BuildTransitionStateMachine :
   Transition ->
   StateMachine ->
   TransitionStateMachine.
Inductive TransitionSource : Set :=
   BuildTransitionSource :
   Transition ->
   AbstractState ->
   TransitionSource.
Inductive TransitionTarget : Set :=
   BuildTransitionTarget :
   Transition ->
   AbstractState ->
   TransitionTarget.

Inductive AbstractStateStateMachine : Set :=
   BuildAbstractStateStateMachine :
   AbstractState ->
   StateMachine ->
   AbstractStateStateMachine.
Inductive AbstractStateCompositeState : Set :=
   BuildAbstractStateCompositeState :
   AbstractState ->
   CompositeState ->
   AbstractStateCompositeState.



Inductive CompositeStateStates : Set :=
   BuildCompositeStateStates :
   CompositeState ->
   list AbstractState ->
   CompositeStateStates.



(* Accessors *)
Definition StateMachine_getStateMachineName (s : StateMachine) : string :=
  match s with BuildStateMachine  name StateMachineID  => name end.
Definition StateMachine_getStateMachineStateMachineID (s : StateMachine) : string :=
  match s with BuildStateMachine  name StateMachineID  => StateMachineID end.
 
Definition Transition_getTransitionLabel (t : Transition) : string :=
  match t with BuildTransition  label TransitionID  => label end.
Definition Transition_getTransitionTransitionID (t : Transition) : string :=
  match t with BuildTransition  label TransitionID  => TransitionID end.
 
Definition AbstractState_getAbstractStateName (a : AbstractState) : string :=
  match a with BuildAbstractState  name AbstractStateID  => name end.
Definition AbstractState_getAbstractStateAbstractStateID (a : AbstractState) : string :=
  match a with BuildAbstractState  name AbstractStateID  => AbstractStateID end.
 
Definition InitialState_getAbstractState (i : InitialState) : AbstractState :=
  match i with BuildInitialState abstractstate InitialStateID  => abstractstate end.
Definition InitialState_getInitialStateInitialStateID (i : InitialState) : string :=
  match i with BuildInitialState abstractstate InitialStateID  => InitialStateID end.
 
Definition RegularState_getAbstractState (r : RegularState) : AbstractState :=
  match r with BuildRegularState abstractstate RegularStateID  => abstractstate end.
Definition RegularState_getRegularStateRegularStateID (r : RegularState) : string :=
  match r with BuildRegularState abstractstate RegularStateID  => RegularStateID end.
 
Definition CompositeState_getAbstractState (c : CompositeState) : AbstractState :=
  match c with BuildCompositeState abstractstate CompositeStateID  => abstractstate end.
Definition CompositeState_getCompositeStateCompositeStateID (c : CompositeState) : string :=
  match c with BuildCompositeState abstractstate CompositeStateID  => CompositeStateID end.
 


		
(* Meta-types *)
Inductive HSMMetamodel_EClass : Set :=
  | StateMachineEClass
  | TransitionEClass
  | AbstractStateEClass
  | InitialStateEClass
  | RegularStateEClass
  | CompositeStateEClass
.

Definition HSMMetamodel_getTypeByEClass (hsec_arg : HSMMetamodel_EClass) : Set :=
  match hsec_arg with
    | StateMachineEClass => StateMachine
    | TransitionEClass => Transition
    | AbstractStateEClass => AbstractState
    | InitialStateEClass => InitialState
    | RegularStateEClass => RegularState
    | CompositeStateEClass => CompositeState
  end.	

Definition HSMMetamodel_getEAttributeTypesByEClass (hsec_arg : HSMMetamodel_EClass) : Set :=
  match hsec_arg with
    | StateMachineEClass => 
    (string * string)
    | TransitionEClass => 
    (string * string)
    | AbstractStateEClass => 
    (string * string)
    | InitialStateEClass => 
    (AbstractState * string)
    | RegularStateEClass => 
    (AbstractState * string)
    | CompositeStateEClass => 
    (AbstractState * string)
  end.

Inductive HSMMetamodel_EReference : Set :=
| StateMachineTransitionsEReference
| StateMachineStatesEReference
| TransitionStateMachineEReference
| TransitionSourceEReference
| TransitionTargetEReference
| AbstractStateStateMachineEReference
| AbstractStateCompositeStateEReference
| CompositeStateStatesEReference
.

Definition HSMMetamodel_getTypeByEReference (hser_arg : HSMMetamodel_EReference) : Set :=
  match hser_arg with
| StateMachineTransitionsEReference => StateMachineTransitions
| StateMachineStatesEReference => StateMachineStates
| TransitionStateMachineEReference => TransitionStateMachine
| TransitionSourceEReference => TransitionSource
| TransitionTargetEReference => TransitionTarget
| AbstractStateStateMachineEReference => AbstractStateStateMachine
| AbstractStateCompositeStateEReference => AbstractStateCompositeState
| CompositeStateStatesEReference => CompositeStateStates
  end.

Definition HSMMetamodel_getERoleTypesByEReference (hser_arg : HSMMetamodel_EReference) : Set :=
  match hser_arg with
| StateMachineTransitionsEReference => (StateMachine * list Transition)
| StateMachineStatesEReference => (StateMachine * list AbstractState)
| TransitionStateMachineEReference => (Transition * StateMachine)
| TransitionSourceEReference => (Transition * AbstractState)
| TransitionTargetEReference => (Transition * AbstractState)
| AbstractStateStateMachineEReference => (AbstractState * StateMachine)
| AbstractStateCompositeStateEReference => (AbstractState * CompositeState)
| CompositeStateStatesEReference => (CompositeState * list AbstractState)
  end.

(* Generic types *)





Inductive HSMMetamodel_EObject : Set :=
 | Build_HSMMetamodel_EObject : 
    forall (hsec_arg: HSMMetamodel_EClass), (HSMMetamodel_getTypeByEClass hsec_arg) -> HSMMetamodel_EObject.

Inductive HSMMetamodel_ELink : Set :=
 | Build_HSMMetamodel_ELink : 
    forall (hser_arg:HSMMetamodel_EReference), (HSMMetamodel_getTypeByEReference hser_arg) -> HSMMetamodel_ELink.

(* Reflective functions *)

Lemma HSMMetamodel_eqEClass_dec : 
 forall (hsec_arg1:HSMMetamodel_EClass) (hsec_arg2:HSMMetamodel_EClass), { hsec_arg1 = hsec_arg2 } + { hsec_arg1 <> hsec_arg2 }.
Proof. repeat decide equality. Defined.

Lemma HSMMetamodel_eqEReference_dec : 
 forall (hser_arg1:HSMMetamodel_EReference) (hser_arg2:HSMMetamodel_EReference), { hser_arg1 = hser_arg2 } + { hser_arg1 <> hser_arg2 }.
Proof. repeat decide equality. Defined.

Definition HSMMetamodel_getEClass (hseo_arg : HSMMetamodel_EObject) : HSMMetamodel_EClass :=
   match hseo_arg with
  | (Build_HSMMetamodel_EObject hseo_arg _) => hseo_arg
   end.

Definition HSMMetamodel_getEReference (hsel_arg : HSMMetamodel_ELink) : HSMMetamodel_EReference :=
   match hsel_arg with
  | (Build_HSMMetamodel_ELink hsel_arg _) => hsel_arg
   end.

Definition HSMMetamodel_instanceOfEClass (hsec_arg: HSMMetamodel_EClass) (hseo_arg : HSMMetamodel_EObject): bool :=
  if HSMMetamodel_eqEClass_dec (HSMMetamodel_getEClass hseo_arg) hsec_arg then true else false.

Definition HSMMetamodel_instanceOfEReference (hser_arg: HSMMetamodel_EReference) (hsel_arg : HSMMetamodel_ELink): bool :=
  if HSMMetamodel_eqEReference_dec (HSMMetamodel_getEReference hsel_arg) hser_arg then true else false.

(** Helper of building EObject for model **)
Definition HSMMetamodel_getEObjectFromEAttributeValues (hsec_arg : HSMMetamodel_EClass) : (HSMMetamodel_getEAttributeTypesByEClass hsec_arg) -> HSMMetamodel_EObject :=
  match hsec_arg with
    | StateMachineEClass => 
    (fun (p: (string * string)) => (Build_HSMMetamodel_EObject StateMachineEClass (BuildStateMachine (fst p) (snd p))))
    | TransitionEClass => 
    (fun (p: (string * string)) => (Build_HSMMetamodel_EObject TransitionEClass (BuildTransition (fst p) (snd p))))
    | AbstractStateEClass => 
    (fun (p: (string * string)) => (Build_HSMMetamodel_EObject AbstractStateEClass (BuildAbstractState (fst p) (snd p))))
    | InitialStateEClass => 
    (fun (p: (AbstractState * string)) => (Build_HSMMetamodel_EObject InitialStateEClass (BuildInitialState (fst p) (snd p))))
    | RegularStateEClass => 
    (fun (p: (AbstractState * string)) => (Build_HSMMetamodel_EObject RegularStateEClass (BuildRegularState (fst p) (snd p))))
    | CompositeStateEClass => 
    (fun (p: (AbstractState * string)) => (Build_HSMMetamodel_EObject CompositeStateEClass (BuildCompositeState (fst p) (snd p))))
  end.

(** Helper of building ELink for model **)
Definition HSMMetamodel_getELinkFromERoleValues (hser_arg : HSMMetamodel_EReference) : (HSMMetamodel_getERoleTypesByEReference hser_arg) -> HSMMetamodel_ELink :=
  match hser_arg with
| StateMachineTransitionsEReference => (fun (p: (StateMachine * list Transition)) => (Build_HSMMetamodel_ELink StateMachineTransitionsEReference (BuildStateMachineTransitions (fst p) (snd p))))
| StateMachineStatesEReference => (fun (p: (StateMachine * list AbstractState)) => (Build_HSMMetamodel_ELink StateMachineStatesEReference (BuildStateMachineStates (fst p) (snd p))))
| TransitionStateMachineEReference => (fun (p: (Transition * StateMachine)) => (Build_HSMMetamodel_ELink TransitionStateMachineEReference (BuildTransitionStateMachine (fst p) (snd p))))
| TransitionSourceEReference => (fun (p: (Transition * AbstractState)) => (Build_HSMMetamodel_ELink TransitionSourceEReference (BuildTransitionSource (fst p) (snd p))))
| TransitionTargetEReference => (fun (p: (Transition * AbstractState)) => (Build_HSMMetamodel_ELink TransitionTargetEReference (BuildTransitionTarget (fst p) (snd p))))
| AbstractStateStateMachineEReference => (fun (p: (AbstractState * StateMachine)) => (Build_HSMMetamodel_ELink AbstractStateStateMachineEReference (BuildAbstractStateStateMachine (fst p) (snd p))))
| AbstractStateCompositeStateEReference => (fun (p: (AbstractState * CompositeState)) => (Build_HSMMetamodel_ELink AbstractStateCompositeStateEReference (BuildAbstractStateCompositeState (fst p) (snd p))))
| CompositeStateStatesEReference => (fun (p: (CompositeState * list AbstractState)) => (Build_HSMMetamodel_ELink CompositeStateStatesEReference (BuildCompositeStateStates (fst p) (snd p))))
  end.

Definition HSMMetamodel_toEClass (hsec_arg : HSMMetamodel_EClass) (hseo_arg : HSMMetamodel_EObject) : option (HSMMetamodel_getTypeByEClass hsec_arg).
Proof.
  destruct hseo_arg as [arg1 arg2].
  destruct (HSMMetamodel_eqEClass_dec arg1 hsec_arg) as [e|] eqn:dec_case.
  - rewrite e in arg2.
    exact (Some arg2).
  - exact None.
Defined.

Definition HSMMetamodel_toEReference (hser_arg : HSMMetamodel_EReference) (hsel_arg : HSMMetamodel_ELink) : option (HSMMetamodel_getTypeByEReference hser_arg).
Proof.
  destruct hsel_arg as [arg1 arg2].
  destruct (HSMMetamodel_eqEReference_dec arg1 hser_arg) as [e|] eqn:dec_case.
  - rewrite e in arg2.
  	exact (Some arg2).
  - exact None.
Defined.

(* Generic functions *)
Definition HSMMetamodel_toEObjectFromStateMachine (st_arg :StateMachine) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject StateMachineEClass st_arg).
Coercion HSMMetamodel_toEObjectFromStateMachine : StateMachine >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromTransition (tr_arg :Transition) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject TransitionEClass tr_arg).
Coercion HSMMetamodel_toEObjectFromTransition : Transition >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromAbstractState (ab_arg :AbstractState) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject AbstractStateEClass ab_arg).
Coercion HSMMetamodel_toEObjectFromAbstractState : AbstractState >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromInitialState (in_arg :InitialState) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject InitialStateEClass in_arg).
Coercion HSMMetamodel_toEObjectFromInitialState : InitialState >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromRegularState (re_arg :RegularState) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject RegularStateEClass re_arg).
Coercion HSMMetamodel_toEObjectFromRegularState : RegularState >-> HSMMetamodel_EObject.

Definition HSMMetamodel_toEObjectFromCompositeState (co_arg :CompositeState) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject CompositeStateEClass co_arg).
Coercion HSMMetamodel_toEObjectFromCompositeState : CompositeState >-> HSMMetamodel_EObject.




(** Metamodel Type Class Instaniation **)
Definition HSMMetamodel_toEObject (hseo_arg : HSMMetamodel_EObject) : HSMMetamodel_EObject := hseo_arg.
Definition HSMMetamodel_toELink (hsel_arg : HSMMetamodel_ELink) : HSMMetamodel_ELink := hsel_arg.
Definition HSMModel := Model HSMMetamodel_EObject HSMMetamodel_ELink.

Definition HSMMetamodel_toEObjectOfEClass (hsec_arg: HSMMetamodel_EClass) (t: HSMMetamodel_getTypeByEClass hsec_arg) : HSMMetamodel_EObject :=
  (Build_HSMMetamodel_EObject hsec_arg t).

Definition HSMMetamodel_toELinkOfEReference (hser_arg: HSMMetamodel_EReference) (t: HSMMetamodel_getTypeByEReference hser_arg) : HSMMetamodel_ELink :=
		  (Build_HSMMetamodel_ELink hser_arg t).


(* Accessors on model *)
(* Equality for Types *)
(*? We currently define eq for Eclass on their fist attribute *)
Definition beq_StateMachine (st_arg1 : StateMachine) (st_arg2 : StateMachine) : bool :=
	( beq_string (getStateMachineName st_arg1) (getStateMachineName st_arg2) ) && 
					( beq_string (getStateMachineStateMachineID st_arg1) (getStateMachineStateMachineID st_arg2) )
.
	
Definition beq_Transition (tr_arg1 : Transition) (tr_arg2 : Transition) : bool :=
	( beq_string (getTransitionLabel tr_arg1) (getTransitionLabel tr_arg2) ) && 
					( beq_string (getTransitionTransitionID tr_arg1) (getTransitionTransitionID tr_arg2) )
.
	
Definition beq_AbstractState (ab_arg1 : AbstractState) (ab_arg2 : AbstractState) : bool :=
	( beq_string (getAbstractStateName ab_arg1) (getAbstractStateName ab_arg2) ) && 
					( beq_string (getAbstractStateAbstractStateID ab_arg1) (getAbstractStateAbstractStateID ab_arg2) )
.
	
Definition beq_InitialState (in_arg1 : InitialState) (in_arg2 : InitialState) : bool :=
	( beq_string (getInitialStateInitialStateID in_arg1) (getInitialStateInitialStateID in_arg2) )
.
	
Definition beq_RegularState (re_arg1 : RegularState) (re_arg2 : RegularState) : bool :=
	( beq_string (getRegularStateRegularStateID re_arg1) (getRegularStateRegularStateID re_arg2) )
.
	
Definition beq_CompositeState (co_arg1 : CompositeState) (co_arg2 : CompositeState) : bool :=
	( beq_string (getCompositeStateCompositeStateID co_arg1) (getCompositeStateCompositeStateID co_arg2) )
.
	




Fixpoint HSMMetamodel_getSuperOfInitialStateOnLinks (in_arg : InitialState) (l : list HSMMetamodel_ELink) : option (AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink InitialStateIsAbstractStateEReference (BuildInitialStateIsAbstractState InitialState_ctr AbstractState_ctr)) :: l' => 
	  if beq_InitialState InitialState_ctr in_arg then Some AbstractState_ctr else HSMMetamodel_getSuperOfInitialStateOnLinks in_arg l'
| _ :: l' => HSMMetamodel_getSuperOfInitialStateOnLinks in_arg l'
| nil => None
end.

Definition getSuperOfInitialState (in_arg : InitialState) (m : HSMModel) : option (AbstractState) :=
  HSMMetamodel_getSuperOfInitialStateOnLinks in_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getSuperOfRegularStateOnLinks (re_arg : RegularState) (l : list HSMMetamodel_ELink) : option (AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink RegularStateIsAbstractStateEReference (BuildRegularStateIsAbstractState RegularState_ctr AbstractState_ctr)) :: l' => 
	  if beq_RegularState RegularState_ctr re_arg then Some AbstractState_ctr else HSMMetamodel_getSuperOfRegularStateOnLinks re_arg l'
| _ :: l' => HSMMetamodel_getSuperOfRegularStateOnLinks re_arg l'
| nil => None
end.

Definition getSuperOfRegularState (re_arg : RegularState) (m : HSMModel) : option (AbstractState) :=
  HSMMetamodel_getSuperOfRegularStateOnLinks re_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getSuperOfCompositeStateOnLinks (co_arg : CompositeState) (l : list HSMMetamodel_ELink) : option (AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink CompositeStateIsAbstractStateEReference (BuildCompositeStateIsAbstractState CompositeState_ctr AbstractState_ctr)) :: l' => 
	  if beq_CompositeState CompositeState_ctr co_arg then Some AbstractState_ctr else HSMMetamodel_getSuperOfCompositeStateOnLinks co_arg l'
| _ :: l' => HSMMetamodel_getSuperOfCompositeStateOnLinks co_arg l'
| nil => None
end.

Definition getSuperOfCompositeState (co_arg : CompositeState) (m : HSMModel) : option (AbstractState) :=
  HSMMetamodel_getSuperOfCompositeStateOnLinks co_arg (@allModelLinks _ _ m).



Fixpoint HSMMetamodel_getSubOfAbstractStateOnLinks (ab_arg : AbstractState) (l : list HSMMetamodel_ELink) : option (HSMMetamodel_EObject) := match l with
 						 						 						 			| (Build_HSMMetamodel_ELink InitialStateIsAbstractStateEReference (BuildInitialStateIsAbstractState InitialState_ctr AbstractState_ctr)) :: l' => 
 				  if beq_AbstractState AbstractState_ctr ab_arg then Some (HSMMetamodel_toEObjectOfEClass  InitialStateEClass InitialState_ctr) else HSMMetamodel_getSubOfAbstractStateOnLinks ab_arg l'
			 			| (Build_HSMMetamodel_ELink RegularStateIsAbstractStateEReference (BuildRegularStateIsAbstractState RegularState_ctr AbstractState_ctr)) :: l' => 
 				  if beq_AbstractState AbstractState_ctr ab_arg then Some (HSMMetamodel_toEObjectOfEClass  RegularStateEClass RegularState_ctr) else HSMMetamodel_getSubOfAbstractStateOnLinks ab_arg l'
			 			| (Build_HSMMetamodel_ELink CompositeStateIsAbstractStateEReference (BuildCompositeStateIsAbstractState CompositeState_ctr AbstractState_ctr)) :: l' => 
 				  if beq_AbstractState AbstractState_ctr ab_arg then Some (HSMMetamodel_toEObjectOfEClass  CompositeStateEClass CompositeState_ctr) else HSMMetamodel_getSubOfAbstractStateOnLinks ab_arg l'
			| _ :: l' => HSMMetamodel_getSubOfAbstractStateOnLinks ab_arg l' 
	| nil => None 
	end.

Definition getSubOfAbstractState (ab_arg : AbstractState) (m : HSMModel) : option (HSMMetamodel_EObject) :=
  HSMMetamodel_getSubOfAbstractStateOnLinks ab_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getStateMachineTransitionsOnLinks (st_arg : StateMachine) (l : list HSMMetamodel_ELink) : option (list Transition) :=
match l with
| (Build_HSMMetamodel_ELink StateMachineTransitionsEReference (BuildStateMachineTransitions StateMachine_ctr transitions_ctr)) :: l' => 
	  if beq_StateMachine StateMachine_ctr st_arg then Some transitions_ctr else HSMMetamodel_getStateMachineTransitionsOnLinks st_arg l'
| _ :: l' => HSMMetamodel_getStateMachineTransitionsOnLinks st_arg l'
| nil => None
end.

Definition getStateMachineTransitions (st_arg : StateMachine) (m : HSMModel) : option (list Transition) :=
  HSMMetamodel_getStateMachineTransitionsOnLinks st_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getStateMachineStatesOnLinks (st_arg : StateMachine) (l : list HSMMetamodel_ELink) : option (list AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink StateMachineStatesEReference (BuildStateMachineStates StateMachine_ctr states_ctr)) :: l' => 
	  if beq_StateMachine StateMachine_ctr st_arg then Some states_ctr else HSMMetamodel_getStateMachineStatesOnLinks st_arg l'
| _ :: l' => HSMMetamodel_getStateMachineStatesOnLinks st_arg l'
| nil => None
end.

Definition getStateMachineStates (st_arg : StateMachine) (m : HSMModel) : option (list AbstractState) :=
  HSMMetamodel_getStateMachineStatesOnLinks st_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getTransitionStateMachineOnLinks (tr_arg : Transition) (l : list HSMMetamodel_ELink) : option (StateMachine) :=
match l with
| (Build_HSMMetamodel_ELink TransitionStateMachineEReference (BuildTransitionStateMachine Transition_ctr stateMachine_ctr)) :: l' => 
	  if beq_Transition Transition_ctr tr_arg then Some stateMachine_ctr else HSMMetamodel_getTransitionStateMachineOnLinks tr_arg l'
| _ :: l' => HSMMetamodel_getTransitionStateMachineOnLinks tr_arg l'
| nil => None
end.

Definition getTransitionStateMachine (tr_arg : Transition) (m : HSMModel) : option (StateMachine) :=
  HSMMetamodel_getTransitionStateMachineOnLinks tr_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getTransitionSourceOnLinks (tr_arg : Transition) (l : list HSMMetamodel_ELink) : option (AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink TransitionSourceEReference (BuildTransitionSource Transition_ctr source_ctr)) :: l' => 
	  if beq_Transition Transition_ctr tr_arg then Some source_ctr else HSMMetamodel_getTransitionSourceOnLinks tr_arg l'
| _ :: l' => HSMMetamodel_getTransitionSourceOnLinks tr_arg l'
| nil => None
end.

Definition getTransitionSource (tr_arg : Transition) (m : HSMModel) : option (AbstractState) :=
  HSMMetamodel_getTransitionSourceOnLinks tr_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getTransitionTargetOnLinks (tr_arg : Transition) (l : list HSMMetamodel_ELink) : option (AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink TransitionTargetEReference (BuildTransitionTarget Transition_ctr target_ctr)) :: l' => 
	  if beq_Transition Transition_ctr tr_arg then Some target_ctr else HSMMetamodel_getTransitionTargetOnLinks tr_arg l'
| _ :: l' => HSMMetamodel_getTransitionTargetOnLinks tr_arg l'
| nil => None
end.

Definition getTransitionTarget (tr_arg : Transition) (m : HSMModel) : option (AbstractState) :=
  HSMMetamodel_getTransitionTargetOnLinks tr_arg (@allModelLinks _ _ m).

Fixpoint HSMMetamodel_getAbstractStateStateMachineOnLinks (ab_arg : AbstractState) (l : list HSMMetamodel_ELink) : option (StateMachine) :=
match l with
| (Build_HSMMetamodel_ELink AbstractStateStateMachineEReference (BuildAbstractStateStateMachine AbstractState_ctr stateMachine_ctr)) :: l' => 
	  if beq_AbstractState AbstractState_ctr ab_arg then Some stateMachine_ctr else HSMMetamodel_getAbstractStateStateMachineOnLinks ab_arg l'
| _ :: l' => HSMMetamodel_getAbstractStateStateMachineOnLinks ab_arg l'
| nil => None
end.

Definition getAbstractStateStateMachine (ab_arg : AbstractState) (m : HSMModel) : option (StateMachine) :=
  HSMMetamodel_getAbstractStateStateMachineOnLinks ab_arg (@allModelLinks _ _ m).
Fixpoint HSMMetamodel_getAbstractStateCompositeStateOnLinks (ab_arg : AbstractState) (l : list HSMMetamodel_ELink) : option (CompositeState) :=
match l with
| (Build_HSMMetamodel_ELink AbstractStateCompositeStateEReference (BuildAbstractStateCompositeState AbstractState_ctr compositeState_ctr)) :: l' => 
	  if beq_AbstractState AbstractState_ctr ab_arg then Some compositeState_ctr else HSMMetamodel_getAbstractStateCompositeStateOnLinks ab_arg l'
| _ :: l' => HSMMetamodel_getAbstractStateCompositeStateOnLinks ab_arg l'
| nil => None
end.

Definition getAbstractStateCompositeState (ab_arg : AbstractState) (m : HSMModel) : option (CompositeState) :=
  HSMMetamodel_getAbstractStateCompositeStateOnLinks ab_arg (@allModelLinks _ _ m).



Fixpoint HSMMetamodel_getCompositeStateStatesOnLinks (co_arg : CompositeState) (l : list HSMMetamodel_ELink) : option (list AbstractState) :=
match l with
| (Build_HSMMetamodel_ELink CompositeStateStatesEReference (BuildCompositeStateStates CompositeState_ctr states_ctr)) :: l' => 
	  if beq_CompositeState CompositeState_ctr co_arg then Some states_ctr else HSMMetamodel_getCompositeStateStatesOnLinks co_arg l'
| _ :: l' => HSMMetamodel_getCompositeStateStatesOnLinks co_arg l'
| nil => None
end.

Definition getCompositeStateStates (co_arg : CompositeState) (m : HSMModel) : option (list AbstractState) :=
  HSMMetamodel_getCompositeStateStatesOnLinks co_arg (@allModelLinks _ _ m).


Definition HSMMetamodel_defaultInstanceOfEClass (hsec_arg: HSMMetamodel_EClass) : (HSMMetamodel_getTypeByEClass hsec_arg) :=
  match hsec_arg with
  | StateMachineEClass => (BuildStateMachine "" "")
  | TransitionEClass => (BuildTransition "" "")
  | AbstractStateEClass => (BuildAbstractState "" "")
  | InitialStateEClass => (BuildInitialState "")
  | RegularStateEClass => (BuildRegularState "")
  | CompositeStateEClass => (BuildCompositeState "")
  end.

(* Typeclass Instance *)
Instance HSMMetamodel : Metamodel HSMMetamodel_EObject HSMMetamodel_ELink HSMMetamodel_EClass HSMMetamodel_EReference :=
  {
    denoteModelClass := HSMMetamodel_getTypeByEClass;
    denoteModelReference := HSMMetamodel_getTypeByEReference;
    toModelClass := HSMMetamodel_toEClass;
    toModelReference := HSMMetamodel_toEReference;
    toModelElement := HSMMetamodel_toEObjectOfEClass;
    toModelLink := HSMMetamodel_toELinkOfEReference;
    bottomModelClass := HSMMetamodel_defaultInstanceOfEClass;

    (* Theorems *)
    eqModelClass_dec := HSMMetamodel_eqEClass_dec;
    eqModelReference_dec := HSMMetamodel_eqEReference_dec;

    (* Constructors *)
    BuildModelElement := Build_HSMMetamodel_EObject;
    BuildModelLink := Build_HSMMetamodel_ELink;
  }.
  
(* Useful lemmas *)
Lemma HSM_invert : 
  forall (hsec_arg: HSMMetamodel_EClass) (t1 t2: HSMMetamodel_getTypeByEClass hsec_arg), Build_HSMMetamodel_EObject hsec_arg t1 = Build_HSMMetamodel_EObject hsec_arg t2 -> t1 = t2.
Proof.
  intros.
  inversion H.
  apply inj_pair2_eq_dec in H1.
  exact H1.
  apply HSMMetamodel_eqEClass_dec.
Qed.
